<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="dist/leaflet.css"/>
    <script src="dist/leaflet.js"></script>
    <script src="dist/axios.min.js"></script>
    <style>
        #mapid {
            height: 99vh;
            width:  99vw;
        }
    </style>
</head>
<body>
    <div id="mapid"></div>
    <script>
        var point = L.latLng(64.1355, -21,8954); //Reykjavik
        var OSM = L.tileLayer("https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png", { attribution: '' });

        var OS = L.layerGroup([OSM])

        var baseLayers = {
            "OSM": OS
        };

        const EarthRadius = 6378137;

        var mymap = L.map('mapid', {
            layers: [OS],
            zoomControl: false,
            useCache: true,
            crossOrigin: true,
        }).setView(point, 14);

        L.control.layers(baseLayers, {}, { collapsed: true }).addTo(mymap);
		
		mymap.attributionControl.setPrefix('<img width="0" height="0">');

        axios.interceptors.request.use(function (config) {
            console.log("Request sent:", config);
            return config;
        }, function (error) {
            console.error("Request error:", error);
            return Promise.reject(error);
        });

        axios.interceptors.response.use(function (response) {
            console.log("Response received:", response);
            return response;
        }, function (error) {
            console.error("Response error:", error);
            return Promise.reject(error);
        });

        async function checkStorageQuota() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const quota = await navigator.storage.estimate();
                    const used = quota.usage;
                    const total = quota.quota;
                    const percentUsed = (used / total) * 100;
                    console.log(`Used: ${(used / (1024 * 1024)).toFixed(2)} MB of ${(total / (1024 * 1024)).toFixed(2)} MB (${percentUsed.toFixed(2)}%)`);
                    if (percentUsed > 85) {
                        console.warn('Warning: You have used more than 85% of available storage!');
                    }
                    return { used, total, percentUsed };
                } catch (error) {
                    console.error('Error assessing storage:', error);
                    return null;
                }
            } else {
                console.warn('StorageManager API is not supported in this browser.');
                return null;
            }
        }

        async function openDatabase() {
            return new Promise((resolve, reject) => {
                var dbRequest = indexedDB.open("mapCache", 1);
                dbRequest.onupgradeneeded = function (event) {
                    var db = event.target.result;
                    db.createObjectStore("tiles", { keyPath: "url" });
                };
                dbRequest.onsuccess = function (event) {
                    resolve(event.target.result);
                };
                dbRequest.onerror = function (event) {
                    console.error("Error opening IndexedDB:", event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function fetchWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await axios.get(url, { responseType: "blob" });
                } catch (error) {
                    if (i < retries - 1) {
                        console.warn(`Retry ${i + 1}/${retries} for ${url}`);
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error;
                    }
                }
            }
        }

        async function cacheTile(url) {
            try {
                const response = await fetchWithRetry(url);
                if (response.status !== 200) {
                    throw new Error(`Network response failed. Status: ${response.status}`);
                }
                const blob = new Blob([response.data]);
                const db = await openDatabase();
                const transaction = db.transaction(["tiles"], "readwrite");
                const store = transaction.objectStore("tiles");
                const putRequest = store.put({ url, blob });
                putRequest.onsuccess = function () {
                    console.log(`Tile cached successfully: ${url}`);
                };
                putRequest.onerror = function (event) {
                    console.error("Error adding tiles to IndexedDB:", event.target.errorCode);
                };
            } catch (error) {
                console.error("Error in cacheTile function:", error);
            }
        }

        async function cacheMapTiles(mymap) {
            const quota = await checkStorageQuota();
            if (quota && quota.percentUsed < 95) {
                const tileUrls = [];
                mymap.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer) {
                        const zoom = mymap.getZoom();
                        const bounds = mymap.getBounds();
                        const tileSize = layer.getTileSize();
                        const nwPoint = mymap.project(bounds.getNorthWest(), zoom).divideBy(tileSize.x).floor();
                        const sePoint = mymap.project(bounds.getSouthEast(), zoom).divideBy(tileSize.y).floor();
                        for (let x = nwPoint.x; x <= sePoint.x; x++) {
                            for (let y = nwPoint.y; y <= sePoint.y; y++) {
                                const tilePoint = new L.Point(x, y);
                                tilePoint.z = zoom;
                                const url = layer.getTileUrl(tilePoint);
                                tileUrls.push(url);
                            }
                        }
                    }
                });
                for (const url of tileUrls) {
                    await cacheTile(url);
                }
            } else {
                console.warn("Tile caching skipped as storage quota is nearly full.");
            }
        }

        async function getCachedTile(url) {
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openDatabase();
                    const transaction = db.transaction(["tiles"], "readonly");
                    const store = transaction.objectStore("tiles");
                    const getRequest = store.get(url);
                    getRequest.onsuccess = function (event) {
                        if (getRequest.result) {
                            resolve(getRequest.result.blob);
                        } else {
                            resolve(null);
                        }
                    };
                    getRequest.onerror = function (event) {
                        console.error("Error retrieving tile from IndexedDB:", event.target.errorCode);
                        resolve(null);
                    };
                } catch (error) {
                    console.error("Error retrieving tile from IndexedDB:", error);
                    resolve(null);
                }
            });
        }

        L.TileLayer.prototype.createTile = function (coords, done) {
            const tile = document.createElement("img");
            const url = this.getTileUrl(coords);
            console.log("Creating tile:", url, "for coords:", coords);
            getCachedTile(url).then((blob) => {
                if (blob) {
                    console.log("Found tile in cache:", url);
                    tile.src = URL.createObjectURL(blob);
                    done(null, tile);
                } else {
                    console.log("Tile not found in cache, fetching:", url);
                    fetchWithRetry(url).then((response) => {
                        if (response.status !== 200) {
                            throw new Error("Network response failed");
                        }
                        const blob = response.data;
                        openDatabase().then((db) => {
                            const transaction = db.transaction(["tiles"], "readwrite");
                            const store = transaction.objectStore("tiles");
                            store.put({ url, blob });
                            console.log("Tile cached:", url);
                        }).catch((dbError) => {
                            console.error("Error caching tile:", dbError);
                        });
                        tile.src = URL.createObjectURL(blob);
                        done(null, tile);
                    }).catch((fetchError) => {
                        console.error("Error fetching tile:", fetchError);
                        tile.src = url;
                        done(null, tile);
                    });
                }
            }).catch((cacheError) => {
                console.error("Error retrieving tile from cache:", cacheError);
                tile.src = url;
                done(null, tile);
            });
            return tile;
        };

        let debounceTimer;
        mymap.on('moveend', function () {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => cacheMapTiles(mymap), 500);
        });
    </script>
</body>
</html>
